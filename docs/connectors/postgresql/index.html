<!DOCTYPE html> <html lang="en"> <head> <title>Debezium Connector for PostgreSQL</title> <meta charset="utf-8"> <meta content="width=device-width, initial-scale=1.0" name="viewport"> <meta content="" name="description"> <meta content="" name="author"> <link href="http://static.jboss.org/theme/css/bootstrap-community/3.2.0.1/bootstrap-community.min.css" media="screen" rel="stylesheet"> <!--[if lt IE 9]><script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script><![endif]--> <link href="http://static.jboss.org/example/images/favicon.ico" rel="shortcut icon"> <link href="http://static.jboss.org/example/images/apple-touch-icon-144x144-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144"> <link href="http://static.jboss.org/example/images/apple-touch-icon-114x114-precomposed.png" rel="apple-touch-icon-precomposed" sizes="114x114"> <link href="http://static.jboss.org/example/images/apple-touch-icon-72x72-precomposed.png" rel="apple-touch-icon-precomposed" sizes="72x72"> <link href="http://static.jboss.org/example/images/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed"> <link href="/stylesheets/debezium.css" rel="stylesheet" type="text/css"> <style>
      @media (min-width: 980px) {
        .banner { background-image: url(http://static.jboss.org/example/images/debezium-banner-1180px.png); height: 110px;  }
      }
      @media (max-width: 979px) {
        .banner { background-image: url(http://static.jboss.org/example/images/debezium-logo.png); background-repeat:no-repeat; background-position: center bottom; height: 60px; }
      }
      @media (max-width: 650px) {
        .banner { width: 100%; margin: 0px auto; }
      }
      @media (max-width: 450px) {
        .banner { height: 90px; }
      }
    </style> <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css" rel="stylesheet"> <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script> <script>
      hljs.initHighlightingOnLoad();
    </script> <script src="http://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script> <style>
      /* adjusting the vertical spacing for when a stickynav is engaged */
      .breadcrumb-fixed > .active {
        color: #8c8f91;
      }
      .breadcrumb-fixed {
        margin: 70px 0 10px;
        padding: 8px 15px;
        margin-bottom: 20px;
        list-style: none;
        background-color: #f5f5f5;
        border-radius: 4px;
      }
      
      .breadcrumb-fixed > li {
        display: inline-block;
      }
    </style> </head> <body> <div id="rhbar"> <a class="jbdevlogo" href="http://www.jboss.org/projects/about"></a> <a class="rhlogo" href="http://www.redhat.com/"></a> </div> <div id=""> <ul class="visuallyhidden" id="top"> <li> <a accesskey="n" href="#nav" title="Skip to navigation">Skip to navigation</a> </li> <li> <a accesskey="c" href="#page" title="Skip to content">Skip to content</a> </li> </ul> <div class="container" id="content"> <div class="navbar navbar-inverse navbar-fix"> <div class="container-fluid"> <div class="navbar-header"> <button class="navbar-toggle collapsed" data-target="#navbar-1" data-toggle="collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/"> Debezium </a> </div> <div class="collapse navbar-collapse" id="navbar-1"> <ul class="nav navbar-nav pull-right"> <li class=""><a href="/docs/faq">FAQ</a></li> <li class="active"><a href="/docs">DOCS</a></li> <li class=""><a href="/community">COMMUNITY</a></li> <li class=""><a href="/blog">BLOG</a></li> </ul> </div> </div> </div> <div id="equalHeightsLayout"> <div class="col-sm-3" id="leftdocnav"> <div class="panel-group" id="accordion1"> <div class="panel panel-docnav"> <div class="panel-heading"> <h4 class="panel-title"> <a class="accordion-toggle" data-parent="#accordion1,#accordion2,#accordion3,#accordion4,#accordion5" data-toggle="collapse" href="#collapse1"> Get Started </a> </h4> </div> <div class="collapse panel-collapse" id="collapse1"><div class="panel-body"> <ul class="list-group"> <li class="list-group-item"><a href="/docs/concepts">Concepts</a></li> <li class="list-group-item"><a href="/docs/tutorial">Tutorial</a></li> <li class="list-group-item"><a href="/docs/install">Installing Debezium</a></li> <li class="list-group-item"><a href="/docs/embedded">Embedding Debezium</a></li> <li class="list-group-item"><a href="/docs/openshift">Running on OpenShift</a></li> <li class="list-group-item"><a href="/docs/monitoring">Monitoring Debezium</a></li> <li class="list-group-item"><a href="/docs/releases">Releases</a></li> </ul> </div></div> </div> </div> <div class="panel-group" id="accordion2"> <div class="panel panel-docnav"> <div class="panel-heading"> <h4 class="panel-title"> <a class="accordion-toggle" data-parent="#accordion1,#accordion2,#accordion3,#accordion4,#accordion5" data-toggle="collapse" href="#collapse2"> Configuration </a> </h4> </div> <div class="collapse panel-collapse" id="collapse2"><div class="panel-body"> <ul class="list-group"> <li class="list-group-item"><a href="/docs/configuration/logging">Logging</a></li> <li class="list-group-item"><a href="/docs/configuration/avro">Avro Serialization</a></li> <li class="list-group-item"><a href="/docs/configuration/topic-routing">Topic Routing</a></li> <li class="list-group-item"><a href="/docs/configuration/event-flattening">CDC Event Flattening</a></li> </ul> </div></div> </div> </div> <div class="panel-group" id="accordion3"> <div class="panel panel-docnav"> <div class="panel-heading"> <h4 class="panel-title"> <a class="accordion-toggle" data-parent="#accordion1,#accordion2,#accordion3,#accordion4,#accordion5" data-toggle="collapse" href="#collapse3"> Connectors </a> </h4> </div> <div class="collapse in panel-collapse" id="collapse3"><div class="panel-body"> <ul class="list-group"> <li class="list-group-item"><a href="/docs/connectors/mysql">MySQL</a></li> <li class="list-group-item"><a href="/docs/connectors/mongodb">MongoDB</a></li> <li class="active list-group-item"><a href="/docs/connectors/postgresql">PostgreSQL</a></li> <li class="list-group-item"><a href="/docs/connectors/oracle">Oracle</a></li> </ul> </div></div> </div> </div> <div class="panel-group" id="accordion4"> <div class="panel panel-docnav"> <div class="panel-heading"> <h4 class="panel-title"> <a class="accordion-toggle" data-parent="#accordion1,#accordion2,#accordion3,#accordion4,#accordion5" data-toggle="collapse" href="#collapse4"> How it works </a> </h4> </div> <div class="collapse panel-collapse" id="collapse4"><div class="panel-body"> <ul class="list-group"> <li class="list-group-item"><a href="/docs/faq">FAQ</a></li> <li class="list-group-item"><a href="/docs/architecture">Debezium Architecture</a></li> <li class="list-group-item"><a href="/docs/features">Debezium Features</a></li> </ul> </div></div> </div> </div> <div class="panel-group" id="accordion5"> <div class="panel panel-docnav"> <div class="panel-heading"> <h4 class="panel-title"> <a class="accordion-toggle" data-parent="#accordion1,#accordion2,#accordion3,#accordion4,#accordion5" data-toggle="collapse" href="#collapse5"> Contribute </a> </h4> </div> <div class="collapse panel-collapse" id="collapse5"><div class="panel-body"> <ul class="list-group"> <li class="list-group-item"><a href="/docs/contribute">Contribute to Debezium</a></li> <li class="list-group-item"><a href="/docs/code-of-conduct">Code of Conduct</a></li> <li class="list-group-item"> <a href="https://twitter.com/debezium">Twitter</a> </li> <li class="list-group-item"> <a href="https://gitter.im/debezium/dev">Chat</a> </li> <li class="list-group-item"> <a href="https://github.com/debezium/">Code</a> </li> <li class="list-group-item"> <a href="https://issues.jboss.org/projects/DBZ/issues">Issues</a> </li> </ul> </div></div> </div> </div> </div> <div class="col-sm-9" id="maincol"> <h1 class="title"> Debezium Connector for PostgreSQL </h1> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Debezium&#8217;s PostgreSQL Connector can monitor and record the row-level changes in the schemas of a PostgreSQL database. This connector was added in Debezium 0.4.0.</p> </div> <div class="paragraph"> <p>The first time it connects to a PostgreSQL server/cluster, it reads a consistent snapshot of all of the schemas. When that snapshot is complete, the connector continuously streams the changes that were committed to PostgreSQL 9.6 or later and generates corresponding insert, update and delete events. All of the events for each table are recorded in a separate Kafka topic, where they can be easily consumed by applications and services.</p> </div> </div> </div> <div class="sect1"> <h2 id="overview">Overview</h2> <div class="sectionbody"> <div class="paragraph"> <p>PostgreSQL&#8217;s <a href="https://www.postgresql.org/docs/9.6/static/logicaldecoding-explanation.html"><em>logical decoding</em></a> feature was first introduced in version 9.4 and is a mechanism which allows the extraction of the changes which were commited to the transaction log and the processing of these changes in a user-friendly manner via the help of an <a href="https://www.postgresql.org/docs/9.6/static/logicaldecoding-output-plugin.html"><em>output plugin</em></a>. This output plugin must be installed prior to running the PostgreSQL server and enabled together with a replication slot in order for clients to be able to consume the changes.</p> </div> <div class="paragraph"> <p>Debezium&#8217;s PostgreSQL connector contains two different parts which work together in order to be able to read and process server changes:</p> </div> <div class="ulist"> <ul> <li> <p>a logical decoding output plugin which has to be installed and configured in the PostgreSQL server, one of</p> <div class="ulist"> <ul> <li> <p><a href="https://github.com/debezium/postgres-decoderbufs">Protobuf based</a></p> </li> <li> <p><a href="https://github.com/eulerto/wal2json">wal2json</a></p> </li> </ul> </div> </li> <li> <p>Java code which reads the changes produced by the plugin in Protobuf format, using PostgreSQL&#8217;s <a href="https://www.postgresql.org/docs/9.6/static/logicaldecoding-walsender.html"><em>streaming replication protocol</em></a>, via the PostgreSQL <a href="https://github.com/pgjdbc/pgjdbc"><em>JDBC driver</em></a></p> </li> </ul> </div> <div class="paragraph"> <p>The connector then produces a <em>change event</em> for every row-level insert, update, and delete operation that was received, recording all the change events for each table in a separate Kafka topic. Your client applications read the Kafka topics that correspond to the database tables they&#8217;re interested in following, and react to every row-level event it sees in those topics.</p> </div> <div class="paragraph"> <p>PostgreSQL normally purges WAL segments after some period of time. This means that the connector won&#8217;t have the complete history of all changes that have been made to the database. Therefore, when the PostgreSQL connector first connects to a particular PostgreSQL database, it starts by performing a <em>consistent snapshot</em> of each of the database schemas. After the connector completes the snapshot, it continues streaming changes from the exact point at which the snapshot was made. This way, we start with a consistent view of all of the data, yet continue reading without having lost any of the changes made while the snapshot was taking place.</p> </div> <div class="paragraph"> <p>The connector is also tolerant of failures. As the connector reads changes and produces events, it records the position in the write-ahead log with each event. If the connector stops for any reason (including communication failures, network problems, or crashes), upon restart it simply continues reading the WAL where it last left off. This includes snapshots: if the snapshot was not completed when the connector is stopped, upon restart it will begin a new snapshot.</p> </div> <div id="limitations" class="admonitionblock important"> <table> <tr> <td class="icon"> <i class="fa icon-important" title="Important"></i> </td> <td class="content"> <div class="paragraph"> <p>The connector&#8217;s functionality relies on PostgreSQL&#8217;s logical decoding feature. Since this is a relatively new feature, it has some limitations which are also reflected by the connector:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>Logical Decoding does not support DDL changes: this means that the connector is unable to report DDL change events back to consumers.</p> </li> <li> <p>Logical Decoding replication slots are only supported on <code>master</code> servers: this means that when there is a cluster of PostgreSQL servers, the connector can only run on the active <code>master</code> server. It cannot run on <code>hot</code> or <code>warm</code> standby replicas. If the <code>master</code> server fails or is demoted, the connector will stop. Once the <code>master</code> has recovered the connector can simply be restarted. If a different PostgreSQL server has been promoted to <code>master</code>, the connector configuration must be adjusted before the connector is restarted. Make sure you read more about how the connector behaves <a href="#when-things-go-wrong">when things go wrong</a>.</p> </li> </ol> </div> </td> </tr> </table> </div> </div> </div> <div class="sect1"> <h2 id="setting-up-PostgreSQL">Setting up PostgreSQL</h2> <div class="sectionbody"> <div class="paragraph"> <p>Before using the Debezium PostgreSQL connector to monitor the changes committed on a PostgreSQL server, first install the logical decoding plugin into the PostgreSQL server, enable a replication slot, and configure a user with sufficient privileges to perform the replication.</p> </div> <div class="paragraph"> <p>Note that <strong>if your database is hosted by a service</strong> such as <a href="https://aws.amazon.com/rds/">Amazon RDS</a> or <a href="https://www.heroku.com/postgres">Heroku Postgres</a> you may be unable to install the plugin. If so, you&#8217;ll be unable to monitor your database with Debezium (support for RDS is <a href="https://issues.jboss.org/browse/DBZ-256">planned</a>).</p> </div> <div class="sect2"> <h3 id="output-plugin">Installing the logical decoding output plugin</h3> <div class="paragraph"> <p>As of PostgreSQL 9.4, the only way to read changes to the write-ahead-log is to first install a logical decoding output plugin. Plugins are written in C, compiled, and installed on the machine which runs the PostgreSQL server. Plugins use a number of PostgreSQL specific APIs, as described by the <a href="https://www.postgresql.org/docs/9.6/static/logicaldecoding-output-plugin.html"><em>PostgreSQL documentation</em></a>.</p> </div> <div class="paragraph"> <p>Debezium&#8217;s PostgreSQL connector works with one of Debezium&#8217;s supported logical decoding plugin to encode the changes in either <a href="https://github.com/google/protobuf"><em>Protobuf format</em></a> or <a href="http://www.json.org/"><em>JSON</em></a> format. The on the plugins' documentation(<a href="https://github.com/debezium/postgres-decoderbufs/blob/master/README.md"><em>protobuf</em></a>, <a href="https://github.com/eulerto/wal2json/blob/master/README.md"><em>wal2json</em></a>) describes the plugin&#8217;s requirements, limitations, and how to compile it.</p> </div> <div class="paragraph"> <p>For simplicity, Debezium also provides a Docker image based on a vanilla PostgreSQL server image on top of which it compiles and installs the plugins. We recommend <a href="https://github.com/debezium/docker-images/tree/master/postgres/9.6"><em>using this image</em></a> as an example of the detailed steps required for the installation.</p> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon"> <i class="fa icon-warning" title="Warning"></i> </td> <td class="content"> <div class="paragraph"> <p>The Debezium logical decoding plugins have only been installed and tested on <em>Linux</em> machines. For Windows and other OSes it may require different installation steps</p> </div> </td> </tr> </table> </div> <div class="sect3"> <h4 id="discrepance-between-plugins">Discrepance between plugins</h4> <div class="paragraph"> <p>The plugins' behaviour is not completely same for all cases. So far these differences have been identified</p> </div> <div class="ulist"> <ul> <li> <p>wal2json plug-in is not able to process qouted identifiers (<a href="https://github.com/eulerto/wal2json/issues/35">issue</a>)</p> </li> <li> <p>wal2json plug-in does not emit events for tables without primary keys</p> </li> </ul> </div> <div class="paragraph"> <p>All up-to-date differences are tracked in a test suite <a href="https://github.com/debezium/debezium/blob/master/debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/DecoderDifferences.java">Java class</a>.</p> </div> </div> <div class="sect3"> <h4 id="server-configuration">Configuring the PostgreSQL server</h4> <div class="paragraph"> <p>Once the <a href="#output-plugin">plugin</a> has been installed, configure the server to load the plugin at startup and to define replication slots:</p> </div> <div class="paragraph"> <p><strong>postgresql.conf</strong></p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code># MODULES&#x000A;shared_preload_libraries = 'decoderbufs,wal2json' <i class="conum" data-value="1"></i><b>(1)</b>&#x000A;&#x000A;# REPLICATION&#x000A;wal_level = logical             <i class="conum" data-value="2"></i><b>(2)</b>&#x000A;max_wal_senders = 1             <i class="conum" data-value="3"></i><b>(3)</b>&#x000A;max_replication_slots = 1       <i class="conum" data-value="4"></i><b>(4)</b></code></pre> </div> </div> <div class="colist arabic"> <table> <tr> <td><i class="conum" data-value="1"></i><b>1</b></td> <td>tells the server that it should load at startup the <code>decoderbufs</code> and <code>wal2json</code> logical decoding plugins (the names of the plugins are set in <a href="https://github.com/debezium/postgres-decoderbufs/blob/v0.3.0/Makefile"><em>Protobuf</em></a> and <a href="https://github.com/eulerto/wal2json/blob/master/Makefile"><em>wal2json</em></a> Makefiles)</td> </tr> <tr> <td><i class="conum" data-value="2"></i><b>2</b></td> <td>tells the server that it should use logical decoding with the write-ahead log</td> </tr> <tr> <td><i class="conum" data-value="3"></i><b>3</b></td> <td>tells the server that it should use a maximum of <code>1</code> separate processes for processing WAL changes</td> </tr> <tr> <td><i class="conum" data-value="4"></i><b>4</b></td> <td>tells the server that it should allow a maximum of <code>1</code> replication slots to be created for streaming WAL changes</td> </tr> </table> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <div class="paragraph"> <p>We strongly recommend reading and understanding <a href="https://www.postgresql.org/docs/9.6/static/wal-configuration.html">the official documentation</a> regarding the mechanics and configuration of the PostgreSQL write-ahead log</p> </div> </td> </tr> </table> </div> </div> </div> <div class="sect2"> <h3 id="PostgreSQL-permissions">Setting up permissions</h3> <div class="paragraph"> <p>Replication can only be performed by a database user that has appropriate permissions and only for a configured number of hosts.</p> </div> <div class="paragraph"> <p>In order to give a user replication permissions, define a PostgreSQL role that has <em>at least</em> the <code>REPLICATION</code> and <code>LOGIN</code> permissions. For example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code>CREATE ROLE name REPLICATION LOGIN;</code></pre> </div> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <div class="paragraph"> <p>Superusers have by default both of the above roles.</p> </div> </td> </tr> </table> </div> <div class="paragraph"> <p>Finally, configure the PostgreSQL server to allow replication to take place between the server machine and the host on which the Debezium PostgreSQL connector is running:</p> </div> <div class="paragraph"> <p><strong>pg_hba.conf</strong></p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code>local   replication     &lt;youruser&gt;                          trust   <i class="conum" data-value="1"></i><b>(1)</b>&#x000A;host    replication     &lt;youruser&gt;  127.0.0.1/32            trust   <i class="conum" data-value="2"></i><b>(2)</b>&#x000A;host    replication     &lt;youruser&gt;  ::1/128                 trust   <i class="conum" data-value="3"></i><b>(3)</b></code></pre> </div> </div> <div class="colist arabic"> <table> <tr> <td><i class="conum" data-value="1"></i><b>1</b></td> <td>tells the server to allow replication for <code>&lt;youruser&gt;</code> locally (i.e. on the server machine)</td> </tr> <tr> <td><i class="conum" data-value="2"></i><b>2</b></td> <td>tells the server to allow <code>&lt;youruser&gt;</code> on <code>localhost</code> to receive replication changes using <code>IPV4</code></td> </tr> <tr> <td><i class="conum" data-value="3"></i><b>3</b></td> <td>tells the server to allow <code>&lt;youruser&gt;</code> on <code>localhost</code> to receive replication changes using <code>IPV6</code></td> </tr> </table> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <div class="paragraph"> <p>See <a href="https://www.postgresql.org/docs/9.6/static/datatype-net-types.html"><em>the PostgreSQL documentation</em></a> for more information on network masks.</p> </div> </td> </tr> </table> </div> </div> </div> </div> <div class="sect1"> <h2 id="supported-PostgreSQL-topologies">Supported PostgreSQL topologies</h2> <div class="sectionbody"> <div class="paragraph"> <p>The PostgreSQL connector can be used with a standalone PostgreSQL server or with a cluster of PostgreSQL servers.</p> </div> <div class="paragraph"> <p>As mentioned <a href="#limitations">in the beginning</a>, PostgreSQL 9.6 only supports logical replication slots on <code>master</code> servers. This means that a replica in a PostgreSQL cluster cannot be configured for logical replication, and consequently that the Debezium PostgreSQL Connector can only connect and communicate with the master server. Should this server fail, the connector will stop. When the cluster is repaired, if the original master server is once again promoted to <code>master</code>, the connector can simply be restarted. However, if a different PostgreSQL server <em>with the plugin and proper configuration</em> is promoted to <code>master</code>, the connector configuration must be changed to point to the new <code>master</code> server and then can be restarted.</p> </div> <div class="sect2"> <h3 id="snapshots">Snapshots</h3> <div class="paragraph"> <p>Most PostgreSQL servers are configured to not retain the complete history of the database in the WAL segments, so the PostgreSQL connector would be unable to see the entire history of the database by simply reading the WAL. So, by default the connector will upon first startup perform an initial <em>consistent snapshot</em> of the database. Each snapshot consists of the following steps:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>Start a transaction with a <a href="https://www.postgresql.org/docs/9.6/static/sql-set-transaction.html">SERIALIZABLE, READ ONLY, DEFERRABLE</a> isolation level to ensure that all subsequent reads within this transaction are done against a single consistent version of the data. Any changes to the data due to subsequent <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations by other clients will not be visible to this transaction.</p> </li> <li> <p>Obtain a <code>SHARE UPDATE EXCLUSIVE MODE</code> lock on each of the monitored tables to ensure that no structural changes can occur to any of the tables while the snapshot is taking place. Note that these locks do not prevent table <code>INSERTS</code>, <code>UPDATES</code> and <code>DELETES</code> from taking place during the operation.</p> </li> <li> <p>Read the current position in the server&#8217;s transaction log.</p> </li> <li> <p>Scan all of the database tables and schemas, and generate a <code>READ</code> event for each row and write that event to the appropriate table-specific Kafka topic.</p> </li> <li> <p>Commit the transaction.</p> </li> <li> <p>Record the successful completion of the snapshot in the connector offsets.</p> </li> </ol> </div> <div class="paragraph"> <p>If the connector fails, is rebalanced, or stops after Step 1 begins but before Step 6 completes, upon restart the connector will begin a new snapshot. Once the connector does complete its initial snapshot, the PostgreSQL connector then continues streaming from the position read during step 3, ensuring that it does not miss any updates. If the connector stops again for any reason, upon restart it will simply continue streaming changes from where it previously left off. However, if the connector remains stopped for long enough, PostgreSQL might purge older WAL segments and the connector&#8217;s last known position may be lost. In this case, when the connector configured with <strong>initial</strong> snapshot mode (the default) is finally restarted, the PostgreSQL server will no longer have the starting point and the connector will not be able to relay the changes that are not available in the write ahead log.</p> </div> <div class="paragraph"> <p>A second snapshot mode allows the connector to perform snapshots <strong>always</strong>. This behavior tells the connector to <em>always</em> perform a snapshot when it starts up, and after the snapshot completes to continue streaming changes from step 3 in the above sequence. This mode can be used in cases when it&#8217;s known that some WAL segments have been deleted and are no longer available, or in case of a cluster failure after a new master has been promoted so that the connector doesn&#8217;t miss out on any potential changes that could&#8217;ve taken place after the new master had been promoted but before the connector was restarted on the new master.</p> </div> <div class="paragraph"> <p>The third snapshot mode instructs the connector to <strong>never</strong> performs snapshots. When a new connector is configured this way, if will either continue streaming changes from a previous stored offset or it will start from the point in time when the PostgreSQL logical replication slot was first created on the server. Note that this mode is useful only when you know all data of interest is still reflected in the WAL.</p> </div> <div class="paragraph"> <p>The final snapshot mode, <strong>initial only</strong>, will perform a database snapshot and then stop before streaming any other changes. If the connector had started but did not complete a snapshot before stopping, the connector will restart the snapshot process and stop once the snapshot completes.</p> </div> </div> <div class="sect2"> <h3 id="streaming-changes">Streaming changes</h3> <div class="paragraph"> <p>The PostgreSQL connector will typically spend the vast majority of its time streaming changes from the PostgreSQL server to which it is connected. This mechanism relies on <a href="https://www.postgresql.org/docs/9.6/static/protocol-replication.html"><em>PostgreSQL&#8217;s replication protocol</em></a> where the client can receive changes from the server as they are committed in the server&#8217;s transaction log at certain positions (also known as <code>Log Sequence Numbers</code> or in short LSNs)</p> </div> <div class="paragraph"> <p>Whenever the server commits a transaction, a separate server process invokes a callback function from the <a href="#output-plugin">logical decoding plugin</a>. This function processes the changes from the transaction, converts them to a specific format (Protobuf or JSON in the case of Debezium plugin) and writes them on an output stream which can then be consumed by clients.</p> </div> <div class="paragraph"> <p>The PostgreSQL connector acts as a PostgreSQL client, and when it receives these changes it transforms the events into Debezium <em>create</em>, <em>update</em>, or <em>delete</em> events that include the LSN position of the event. The PostgreSQL connector forwards these change events to the Kafka Connect framework (running in the same process), which then asynchronously writes them in the same order to the appropriate Kafka topic. Kafka Connect uses the term <em>offset</em> for the source-specific position information that Debezium includes with each event, and Kafka Connect periodically records the most recent offset in another Kafka topic.</p> </div> <div class="paragraph"> <p>When Kafka Connect gracefully shuts down, it stops the connectors, flushes all events to Kafka, and records the last offset received from each connector. Upon restart, Kafka Connect reads the last recorded offset for each connector, and starts the connector from that point. The PostgreSQL connector uses the LSN recorded in each change event as the offset, so that upon restart the connector requests the PostgreSQL server send it the events starting just after that position.</p> </div> </div> <div class="sect2"> <h3 id="topic-names">Topics names</h3> <div class="paragraph"> <p>The PostgreSQL connector writes events for all insert, update, and delete operations on a single table to a single Kafka topic. The name of the Kafka topics takes by default the form <em>serverName</em>.<em>schemaName</em>.<em>tableName</em>, where <em>serverName</em> is the logical name of the connector as specified with the <code>database.server.name</code> configuration property, <em>schemaName</em> is the name of the database schema where the operation occurred, and <em>tableName</em> is the name of the database table on which the operation occurred.</p> </div> <div class="paragraph"> <p>For example, consider a PostgreSQL installation with a <code>postgres</code> database and an <code>inventory</code> schema that contains four tables: <code>products</code>, <code>products_on_hand</code>, <code>customers</code>, and <code>orders</code>. If the connector monitoring this database were given a logical server name of <code>fulfillment</code>, then the connector would produce events on these four Kafka topics:</p> </div> <div class="ulist"> <ul> <li> <p><code>fulfillment.inventory.products</code></p> </li> <li> <p><code>fulfillment.inventory.products_on_hand</code></p> </li> <li> <p><code>fulfillment.inventory.customers</code></p> </li> <li> <p><code>fulfillment.inventory.orders</code></p> </li> </ul> </div> <div class="paragraph"> <p>If on the other hand the tables were not part of a specific schema but rather created in the default <code>public</code> PostgreSQL schema, then the name of the Kafka topics would be:</p> </div> <div class="ulist"> <ul> <li> <p><code>fulfillment.public.products</code></p> </li> <li> <p><code>fulfillment.public.products_on_hand</code></p> </li> <li> <p><code>fulfillment.public.customers</code></p> </li> <li> <p><code>fulfillment.public.orders</code></p> </li> </ul> </div> </div> <div class="sect2"> <h3 id="meta-info">Meta information</h3> <div class="paragraph"> <p>Each <code>record</code> produced by the PostgreSQL connector has, in addition to the <a href="#events"><em>database event</em></a>, some meta-information about where the event occurred on the server, the name of the source partition and the name of the Kafka topic and partition where the event should be placed:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-json" data-lang="json">"sourcePartition": {&#x000A;     "server": "fulfillment"&#x000A; },&#x000A; "sourceOffset": {&#x000A;     "lsn": "24023128",&#x000A;     "txId": "555",&#x000A;     "ts_usec": "1482918357011699"&#x000A; },&#x000A; "kafkaPartition": null</code></pre> </div> </div> <div class="paragraph"> <p>The PostgreSQL connector uses only 1 Kafka Connect <em>partition</em> and it places the generated events into 1 Kafka partition. Therefore, the name of the <code>sourcePartition</code> will always default to the name of the <code>database.server.name</code> configuration property, while the <code>kafkaPartition</code> has the value <code>null</code> which means that the connector does not use a specific Kafka partition.</p> </div> <div class="paragraph"> <p>The <code>sourceOffset</code> portion of the message contains information about the location of the server where the event occurred:</p> </div> <div class="ulist"> <ul> <li> <p><code>lsn</code> represents the PostgreSQL <a href="https://www.postgresql.org/docs/9.6/static/datatype-pg-lsn.html"><em>log sequence number</em></a> or <code>offset</code> in the transaction log</p> </li> <li> <p><code>txId</code> represents the identifier of the server transaction which caused the event</p> </li> <li> <p><code>ts_usec</code> represents the number of microseconds since Unix Epoch as the server time at which the transaction was committed</p> </li> </ul> </div> </div> <div class="sect2"> <h3 id="events">Events</h3> <div class="paragraph"> <p>All data change events produced by the PostgreSQL connector have a key and a value, although the structure of the key and value depend on the table from which the change events originated (see <a href="#topic-names">Topic names</a>).</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <div class="paragraph"> <p>Starting with Kafka 0.10, Kafka can optionally record with the message key and value the <a href="http://kafka.apache.org/documentation.html#upgrade_10_performance_impact"><em>timestamp</em></a> at which the message was created (recorded by the producer) or written to the log by Kafka.</p> </div> </td> </tr> </table> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon"> <i class="fa icon-warning" title="Warning"></i> </td> <td class="content"> <div class="paragraph"> <p>The Debezium PostgreSQL connector ensures that all Kafka Connect <em>schema names</em> are <a href="http://avro.apache.org/docs/current/spec.html#names">valid Avro schema names</a>. This means that the logical server name must start with Latin letters or an underscore (e.g., [a-z,A-Z,_]), and the remaining characters in the logical server name and all characters in the schema and table names must be Latin letters, digits, or an underscore (e.g., [a-z,A-Z,0-9,\_]). If not, then all invalid characters will automatically be replaced with an underscore character.</p> </div> <div class="paragraph"> <p>This can lead to unexpected conflicts when the logical server name, schema names, and table names contain other characters, and the only distinguishing characters between table full names are invalid and thus replaced with underscores.</p> </div> </td> </tr> </table> </div> <div class="paragraph"> <p>Debezium and Kafka Connect are designed around <em>continuous streams of event messages</em>, and the structure of these events may change over time. This could be difficult for consumers to deal with, so to make it easy Kafka Connect makes each event self-contained. Every message key and value has two parts: a <em>schema</em> and <em>payload</em>. The schema describes the structure of the payload, while the payload contains the actual data.</p> </div> <div class="sect3"> <h4 id="change-events-key">Change event&#8217;s key</h4> <div class="paragraph"> <p>For a given table, the change event&#8217;s key will have a structure that contains a field for each column in the primary key (or unique key constraint) of the table at the time the event was created.</p> </div> <div class="paragraph"> <p>Consider a <code>customers</code> table defined in the <code>public</code> database schema:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-sql" data-lang="sql">CREATE TABLE customers (&#x000A;  id SERIAL,&#x000A;  first_name VARCHAR(255) NOT NULL,&#x000A;  last_name VARCHAR(255) NOT NULL,&#x000A;  email VARCHAR(255) NOT NULL,&#x000A;  PRIMARY KEY(id)&#x000A;);</code></pre> </div> </div> <div class="paragraph"> <p>If the <code>database.server.name</code> configuration property has the value <code>PostgreSQL_server</code>, every change event for the <code>customers</code> table while it has this definition will feature the same key structure, which in JSON looks like this:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-json" data-lang="json">{&#x000A;  "schema": {&#x000A;    "type": "struct",&#x000A;    "name": "PostgreSQL_server.public.customers.Key"&#x000A;    "optional": false,&#x000A;    "fields": [&#x000A;          {&#x000A;              "name": "id",&#x000A;              "index": "0",&#x000A;              "schema": {&#x000A;                  "type": "INT32",&#x000A;                  "optional": "false"&#x000A;              }&#x000A;          }&#x000A;      ]&#x000A;  },&#x000A;  "payload": {&#x000A;      "id": "1"&#x000A;  },&#x000A;}</code></pre> </div> </div> <div class="paragraph"> <p>The <code>schema</code> portion of the key contains a Kafka Connect schema describing what is in the key portion, and in our case that means that the <code>payload</code> value is not optional, is a structure defined by a schema named <code>PostgreSQL_server.public.customers.Key</code>, and has one required field named <code>id</code> of type <code>int32</code>. If we look at the value of the key&#8217;s <code>payload</code> field, we&#8217;ll see that it is indeed a structure (which in JSON is just an object) with a single <code>id</code> field, whose value is <code>1</code>.</p> </div> <div class="paragraph"> <p>Therefore, we interpret this key as describing the row in the <code>public.customers</code> table (output from the connector named <code>PostgreSQL_server</code>) whose <code>id</code> primary key column had a value of <code>1</code>.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <div class="paragraph"> <p>Although the <code>column.blacklist</code> configuration property allows you to remove columns from the event values, all columns in a primary or unique key are always included in the event&#8217;s key.</p> </div> </td> </tr> </table> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon"> <i class="fa icon-warning" title="Warning"></i> </td> <td class="content"> <div class="paragraph"> <p>If the table does not have a primary or unique key, then the change event&#8217;s key will be null. This makes sense since the rows in a table without a primary or unique key constraint cannot be uniquely identified.</p> </div> </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="change-events-value">Change event&#8217;s value</h4> <div class="paragraph"> <p>The value of the change event message is a bit more complicated. Like the key message, it has a <em>schema</em> section and <em>payload</em> section. The payload section of every change event value produced by the PostgreSQL connector has an <em>envelope</em> structure with the following fields:</p> </div> <div class="ulist"> <ul> <li> <p><code>op</code> is a mandatory field that contains a string value describing the type of operation. Values for the PostgreSQL connector are <code>c</code> for create (or insert), <code>u</code> for update, <code>d</code> for delete, and <code>r</code> for read (in the case of a snapshot).</p> </li> <li> <p><code>before</code> is an optional field that if present contains the state of the row <em>before</em> the event occurred. The structure will be described by the <code>PostgreSQL_server.public.customers.Value</code> Kafka Connect schema, which the <code>PostgreSQL_server</code> connector uses for all rows in the <code>public.customers</code> table.</p> </li> </ul> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon"> <i class="fa icon-warning" title="Warning"></i> </td> <td class="content"> <div class="paragraph"> <p>Whether or not this field is available is highly dependent on the <a href="#replica-identity"><em>REPLICA IDENTITY</em></a> setting for each table</p> </div> </td> </tr> </table> </div> <div class="ulist"> <ul> <li> <p><code>after</code> is an optional field that if present contains the state of the row <em>after</em> the event occurred. The structure is describe by the same <code>PostgreSQL_server.public.customers.Value</code> Kafka Connect schema used in <code>before</code>.</p> </li> <li> <p><code>source</code> is a mandatory field that contains a structure describing the source metadata for the event, which in the case of PostgreSQL contains several fields: the connector name, whether the event is part of an ongoing snapshot or not and the same fields from the record&#8217;s <a href="#meta-info"><em>meta information</em></a> section</p> </li> <li> <p><code>ts_ms</code> is optional and if present contains the time (using the system clock in the JVM running the Kafka Connect task) at which the connector processed the event.</p> </li> </ul> </div> <div class="paragraph"> <p>And of course, the <em>schema</em> portion of the event message&#8217;s value contains a schema that describes this envelope structure and the nested fields within it.</p> </div> <div class="sect4"> <h5 id="replica-identity">Replica Identity</h5> <div class="paragraph"> <p><a href="https://www.postgresql.org/docs/9.6/static/sql-altertable.html#SQL-CREATETABLE-REPLICA-IDENTITY">REPLICA IDENTITY</a> is a PostgreSQL specific table-level setting which determines the amount of information that is available to <code>logical decoding</code> in case of <code>UPDATE</code> and <code>DELETE</code> events. More specifically, this controls what (if any) information is available regarding the previous values of the table columns involved, whenever one of the aforementioned events occur.</p> </div> <div class="paragraph"> <p>There are 4 possible values for <code>REPLICA IDENTITY</code>:</p> </div> <div class="ulist"> <ul> <li> <p>DEFAULT - <code>UPDATE</code> and <code>DELETE</code> events will only contain the previous values for the primary key columns of a table</p> </li> <li> <p>NOTHING - <code>UPDATE</code> and <code>DELETE</code> events will not contain any information about the previous value on any of the table columns</p> </li> <li> <p>FULL - <code>UPDATE</code> and <code>DELETE</code> events will contain the previous values of all the table&#8217;s columns</p> </li> <li> <p>INDEX <code>index name</code> - <code>UPDATE</code> and <code>DELETE</code> events will contains the previous values of the columns contained in the index definition named <code>index name</code></p> </li> </ul> </div> </div> <div class="sect4"> <h5 id="create-events">Create events</h5> <div class="paragraph"> <p>Let&#8217;s look at what a <em>create</em> event value might look like for our <code>customers</code> table:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-json" data-lang="json">{&#x000A;    "schema": {&#x000A;        "type": "struct",&#x000A;        "optional": false,&#x000A;        "name": "PostgreSQL_server.public.customers.Envelope",&#x000A;        "version": 1,&#x000A;        "fields": [&#x000A;            {&#x000A;                "field": "op",&#x000A;                "type": "string",&#x000A;                "optional": false&#x000A;            },&#x000A;            {&#x000A;                "field": "before",&#x000A;                "type": "struct",&#x000A;                "optional": true,&#x000A;                "name": "PostgreSQL_server.public.customers.Value",&#x000A;                "fields": [&#x000A;                    {&#x000A;                        "type": "int32",&#x000A;                        "optional": false,&#x000A;                        "field": "id"&#x000A;                    }&#x000A;                ]&#x000A;            },&#x000A;            {&#x000A;                "field": "after",&#x000A;                "type": "struct",&#x000A;                "name": "PostgreSQL_server.public.customers.Value",&#x000A;                "optional": true,&#x000A;                "fields": [&#x000A;                    {&#x000A;                        "type": "int32",&#x000A;                        "optional": false,&#x000A;                        "field": "id"&#x000A;                    },&#x000A;                    {&#x000A;                        "type": "string",&#x000A;                        "optional": false,&#x000A;                        "field": "first_name"&#x000A;                    },&#x000A;                    {&#x000A;                        "type": "string",&#x000A;                        "optional": false,&#x000A;                        "field": "last_name"&#x000A;                    },&#x000A;                    {&#x000A;                        "type": "string",&#x000A;                        "optional": false,&#x000A;                        "field": "email"&#x000A;                    }&#x000A;                ]&#x000A;            },&#x000A;            {&#x000A;                "field": "source",&#x000A;                "type": "struct",&#x000A;                "name": "io.debezium.connector.postgresql.Source",&#x000A;                "optional": false,&#x000A;                "fields": [&#x000A;                    {&#x000A;                        "name": "name",&#x000A;                        "index": "0",&#x000A;                        "schema": {&#x000A;                            "type": "STRING",&#x000A;                            "optional": "false"&#x000A;                        }&#x000A;                    },&#x000A;                    {&#x000A;                        "name": "ts_usec",&#x000A;                        "index": "1",&#x000A;                        "schema": {&#x000A;                            "type": "INT64",&#x000A;                            "optional": "true"&#x000A;                        }&#x000A;                    },&#x000A;                    {&#x000A;                        "name": "txId",&#x000A;                        "index": "2",&#x000A;                        "schema": {&#x000A;                            "type": "INT32",&#x000A;                            "optional": "true"&#x000A;                        }&#x000A;                    },&#x000A;                    {&#x000A;                        "name": "lsn",&#x000A;                        "index": "3",&#x000A;                        "schema": {&#x000A;                            "type": "INT64",&#x000A;                            "optional": "true"&#x000A;                        }&#x000A;                    },&#x000A;                    {&#x000A;                        "name": "snapshot",&#x000A;                        "index": "4",&#x000A;                        "schema": {&#x000A;                            "type": "BOOLEAN",&#x000A;                            "optional": "true"&#x000A;                        }&#x000A;                    },&#x000A;                    {&#x000A;                        "name": "last_snapshot_record",&#x000A;                        "index": "5",&#x000A;                        "schema": {&#x000A;                            "type": "BOOLEAN",&#x000A;                            "optional": "true"&#x000A;                        }&#x000A;                    }&#x000A;                ]&#x000A;            },&#x000A;            {&#x000A;                "field": "ts_ms",&#x000A;                "type": "int64",&#x000A;                "optional": true&#x000A;            }&#x000A;        ]&#x000A;    },&#x000A;    "payload": {&#x000A;        "op": "c",&#x000A;        "ts_ms": 1465491411815,&#x000A;        "before": null,&#x000A;        "after": {&#x000A;            "id": 1,&#x000A;            "first_name": "Anne",&#x000A;            "last_name": "Kretchmar",&#x000A;            "email": "annek@noanswer.org"&#x000A;        },&#x000A;        "source": {&#x000A;            "name": "PostgreSQL_server",&#x000A;            "ts_usec": "1482918357011699",&#x000A;            "txId": "555",&#x000A;            "lsn": "24023128",&#x000A;            "snapshot": null,&#x000A;            "last_snapshot_record": null&#x000A;        }&#x000A;    }&#x000A;}</code></pre> </div> </div> <div class="paragraph"> <p>If we look at the <code>schema</code> portion of this event&#8217;s <em>value</em>, we can see the schema for the <em>envelope</em>, the schema for the <code>source</code> structure (which is specific to the PostgreSQL connector and reused across all events), and the table-specific schemas for the <code>before</code> and <code>after</code> fields.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <div class="paragraph"> <p>The names of the schemas for the <code>before</code> and <code>after</code> fields are of the form <em>logicalName</em>.<em>schemaName</em>.<em>tableName</em>.Value, and thus are entirely independent from all other schemas for all other tables. This means that when using the <a href="/docs/faq#avro-converter">Avro Converter</a>, the resulting Avro schems for <em>each table</em> in each <em>logical source</em> have their own evolution and history.</p> </div> </td> </tr> </table> </div> <div class="paragraph"> <p>If we look at the <code>payload</code> portion of this event&#8217;s <em>value</em>, we can see the information in the event, namely that it is describing that the row was created (since <code>op=c</code>), and that the <code>after</code> field value contains the values of the new inserted row&#8217;s' <code>id</code>, <code>first_name</code>, <code>last_name</code>, and <code>email</code> columns.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <div class="paragraph"> <p>It may appear that the JSON representations of the events are much larger than the rows they describe. This is true, because the JSON representation must include the <em>schema</em> and the <em>payload</em> portions of the message. It is possible and even recommended to use the <a href="/docs/faq#avro-converter">Avro Converter</a> to dramatically decrease the size of the actual messages written to the Kafka topics.</p> </div> </td> </tr> </table> </div> </div> <div class="sect4"> <h5 id="update-events">Update events</h5> <div class="paragraph"> <p>The value of an <em>update</em> change event on this table will actually have the exact same <em>schema</em>, and its payload will be structured the same but will hold different values. Here&#8217;s an example:</p> </div> <div class="paragraph"> <p>Here&#8217;s that new event&#8217;s <em>value</em> formatted to be easier to read:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-json" data-lang="json">{&#x000A;    "schema": { ... },&#x000A;    "payload": {&#x000A;        "before": {&#x000A;            "id": 1&#x000A;        },&#x000A;        "after": {&#x000A;            "id": 1,&#x000A;            "first_name": "Anne Marie",&#x000A;            "last_name": "Kretchmar",&#x000A;            "email": "annek@noanswer.org"&#x000A;        },&#x000A;        "source": {&#x000A;            "name": "PostgreSQL_server",&#x000A;            "ts_usec": "1482918357011699",&#x000A;            "txId": "556",&#x000A;            "lsn": "26523128",&#x000A;            "snapshot": null,&#x000A;            "last_snapshot_record": null&#x000A;        },&#x000A;        "op": "u",&#x000A;        "ts_ms": 1465584025523&#x000A;    }&#x000A;}</code></pre> </div> </div> <div class="paragraph"> <p>When we compare this to the value in the <em>insert</em> event, we see a couple of differences in the <code>payload</code> section:</p> </div> <div class="ulist"> <ul> <li> <p>The <code>op</code> field value is now <code>u</code>, signifying that this row changed because of an update</p> </li> <li> <p>The <code>before</code> field now has the state of the row with the values before the database commit, but only for the primary key column <code>id</code>. This is because the <a href="#replica-identity"><em>REPLICA IDENTITY</em></a> which is by default <code>DEFAULT</code>.</p> </li> </ul> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <div class="paragraph"> <p>Should we want to see the previous values of all the columns for the row, we would have to change the <code>customers</code> table first by running <code>ALTER TABLE customers REPLICA IDENTITY FULL</code></p> </div> </td> </tr> </table> </div> <div class="ulist"> <ul> <li> <p>The <code>after</code> field now has the updated state of the row, and here was can see that the <code>first_name</code> value is now <code>Anne Marie</code>.</p> </li> <li> <p>The <code>source</code> field structure has the same fields as before, but the values are different since this event is from a different position in the WAL.</p> </li> <li> <p>The <code>ts_ms</code> shows the timestamp that Debezium processed this event.</p> </li> </ul> </div> <div class="paragraph"> <p>There are several things we can learn by just looking at this <code>payload</code> section. We can compare the <code>before</code> and <code>after</code> structures to determine what actually changed in this row because of the commit. The <code>source</code> structure tells us information about PostgreSQL&#8217;s record of this change (providing traceability), but more importantly this has information we can compare to other events in this and other topics to know whether this event occurred before, after, or as part of the same PostgreSQL commit as other events.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <div class="paragraph"> <p>When the columns for a row&#8217;s primary/unique key are updated, the value of the row&#8217;s key has changed so Debezium will output <em>three</em> events: a <code>DELETE</code> event and <a href="#tombstone-events">tombstone event</a> with the old key for the row, followed by an <code>INSERT</code> event with the new key for the row.</p> </div> </td> </tr> </table> </div> </div> <div class="sect4"> <h5 id="delete-events">Delete events</h5> <div class="paragraph"> <p>So far we&#8217;ve seen samples of <em>create</em> and <em>update</em> events. Now, let&#8217;s look at the value of a <em>delete</em> event for the same table. Once again, the <code>schema</code> portion of the value will be exactly the same as with the <em>create</em> and <em>update</em> events:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-json" data-lang="json">{&#x000A;    "schema": { ... },&#x000A;    "payload": {&#x000A;        "before": {&#x000A;            "id": 1&#x000A;        },&#x000A;        "after": null,&#x000A;        "source": {&#x000A;            "name": "PostgreSQL_server",&#x000A;            "ts_usec": "154918657011699",&#x000A;            "txId": "557",&#x000A;            "lsn": "46523128",&#x000A;            "snapshot": null,&#x000A;            "last_snapshot_record": null&#x000A;        },&#x000A;        "op": "d",&#x000A;        "ts_ms": 1465581902461&#x000A;    }&#x000A;}</code></pre> </div> </div> <div class="paragraph"> <p>If we look at the <code>payload</code> portion, we see a number of differences compared with the <em>create</em> or <em>update</em> event payloads:</p> </div> <div class="ulist"> <ul> <li> <p>The <code>op</code> field value is now <code>d</code>, signifying that this row was deleted</p> </li> <li> <p>The <code>before</code> field now has the state of the row that was deleted with the database commit. Again this only contains the primary key column due to the <a href="#replica-identity"><em>REPLICA IDENTITY</em></a> setting</p> </li> <li> <p>The <code>after</code> field is null, signifying that the row no longer exists</p> </li> <li> <p>The <code>source</code> field structure has many of the same values as before, except the <code>ts_usec</code>, <code>lsn</code> and <code>txId</code> fields have changed</p> </li> <li> <p>The <code>ts_ms</code> shows the timestamp that Debezium processed this event.</p> </li> </ul> </div> <div class="paragraph"> <p>This event gives a consumer all kinds of information that it can use to process the removal of this row.</p> </div> <div class="paragraph"> <p>The PostgreSQL connector&#8217;s events are designed to work with <a href="https://cwiki.apache.org/confluence/display/KAFKA/Log+Compaction">Kafka log compaction</a>, which allows for the removal of some older messages as long as at least the most recent message for every key is kept. This allows Kafka to reclaim storage space while ensuring the topic contains a complete dataset and can be used for reloading key-based state.</p> </div> <div id="tombstone-events" class="paragraph"> <p>When a row is deleted, the <em>delete</em> event value listed above still works with log compaction, since Kafka can still remove all earlier messages with that same key. But only if the message value is <code>null</code> will Kafka know that it can remove <em>all messages</em> with that same key. To make this possible, Debezium&#8217;s PostgreSQL connector always follows the <em>delete</em> event with a special <em>tombstone</em> event that has the same key but <code>null</code> value.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <div class="paragraph"> <p>As of Kafka 0.10, the JSON converter provided by Kafka Connect never results in a null value for the message (<a href="https://issues.apache.org/jira/browse/KAFKA-3832">KAFKA-3832</a>). Therefore, Kafka&#8217;s log compaction will always retain the last message, even when the tombstone event is supplied, though it will be free to remove all prior messages with the same key. In other words, until this is fixed using the JSON Converter will reduce the effectiveness of Kafka&#8217;s log compaction.</p> </div> <div class="paragraph"> <p>In the meantime, consider using the <a href="/docs/faq#avro-converter">Avro Converter</a>, which does properly return a null value and will thus take full advantage of Kafka log compaction.</p> </div> </td> </tr> </table> </div> </div> </div> </div> <div class="sect2"> <h3 id="data-types">Data types</h3> <div class="paragraph"> <p>As described above, the PostgreSQL connector represents the changes to rows with events that are structured like the table in which the row exist. The event contains a field for each column value, and how that value is represented in the event depends on the PostgreSQL data type of the column. This section describes this mapping.</p> </div> <div class="paragraph"> <p>The following table describes how the connector maps each of the PostgreSQL data types to a <em>literal type</em> and <em>semantic type</em> within the events' fields.</p> </div> <div class="paragraph"> <p>Here, the <em>literal type</em> describes how the value is literally represented using Kafka Connect schema types, namely <code>INT8</code>, <code>INT16</code>, <code>INT32</code>, <code>INT64</code>, <code>FLOAT32</code>, <code>FLOAT64</code>, <code>BOOLEAN</code>, <code>STRING</code>, <code>BYTES</code>, <code>ARRAY</code>, <code>MAP</code>, and <code>STRUCT</code>.</p> </div> <div class="paragraph"> <p>The <em>semantic type</em> describes how the Kafka Connect schema captures the <em>meaning</em> of the field using the name of the Kafka Connect schema for the field.</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 20%;"> <col style="width: 15%;"> <col style="width: 30%;"> <col style="width: 35%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">PostgreSQL Data Type</th> <th class="tableblock halign-left valign-top">Literal type (schema type)</th> <th class="tableblock halign-left valign-top">Semantic type (schema name)</th> <th class="tableblock halign-left valign-top">Notes</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>POINT</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRUCT</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.data.geometry.Point</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Contains a structure with 2 <code>FLOAT64</code> fields - <code>(x,y)</code> - each representing the coordinates of a geometric point</p> </div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BOOLEAN</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BOOLEAN</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BIT(1)</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BOOLEAN</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BIT( &gt; 1)</code>, <code>BIT VARYING[(M)]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BYTES</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.data.Bits</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The <code>length</code> schema parameter contains an integer representing the number of bits. The resulting <code>byte[]</code> will contain the bits in little-endian form and will be sized to contain at least the specified number of bits (e.g., <code>numBytes = n/8 + (n%8== 0 ? 0 : 1)</code> where <code>n</code> is the number of bits).</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>SMALLINT</code>, <code>SMALLSERIAL</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT16</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INTEGER</code>, <code>SERIAL</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT32</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BIGINT</code>, <code>BIGSERIAL</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>REAL</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>FLOAT32</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>DOUBLE PRECISION</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>FLOAT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>CHAR[(M)]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>VARCHAR[(M)]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>CHARACTER[(M)]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>CHARACTER VARYING[(M)]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIMESTAMPTZ</code>, <code>TIMESTAMP WITH TIME ZONE</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.ZonedTimestamp</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>A string representation of a timestamp with timezone information, where the timezone is GMT</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIMETZ</code>, <code>TIME WITH TIME ZONE</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.ZonedTime</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>A string representation of a time value with timezone information, where the timezone is GMT</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INTERVAL [P]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>FLOAT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.MicroDuration</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The number of micro seconds for a time interval using the <code>365.25 / 12.0</code> formula for days per month average</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BYTEA</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BYTES</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>n/a</p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>JSON</code>, <code>JSONB</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.data.Json</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Contains the string representation of a JSON document, array, or scalar.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>XML</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.data.Xml</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Contains the string representation of an XML document</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>UUID</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRING</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.data.Uuid</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Contains the string representation of a PostgreSQL UUID value</p> </div></div></td> </tr> </tbody> </table> <div class="paragraph"> <p>Other data type mappings are described in the following sections.</p> </div> <div class="sect3"> <h4 id="temporal-values">Temporal values</h4> <div class="paragraph"> <p>Other than PostgreSQL&#8217;s <code>TIMESTAMPTZ</code> and <code>TIMETZ</code> data types (which contain time zone information), the other temporal types depend on the value of the <code>time.precision.mode</code> configuration property. When the <code>time.precision.mode</code> configuration property is set to <code>adaptive</code> (the default), then the connector will determine the literal type and semantic type for the temporal types based on the column&#8217;s data type definition so that events <em>exactly</em> represent the values in the database:</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 20%;"> <col style="width: 15%;"> <col style="width: 30%;"> <col style="width: 35%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">PostgreSQL Data Type</th> <th class="tableblock halign-left valign-top">Literal type (schema type)</th> <th class="tableblock halign-left valign-top">Semantic type (schema name)</th> <th class="tableblock halign-left valign-top">Notes</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIMESTAMP(4)</code> , <code>TIMESTAMP(5)</code>, <code>TIMESTAMP(6)</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.MicroTimestamp</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of milliseconds past epoch, and does not include timezone information.</p> </div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>DATE</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT32</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.Date</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of days since epoch.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIME(1)</code>, <code>TIME(2)</code>, <code>TIME(3)</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT32</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.Time</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of milliseconds past midnight, and does not include timezone information.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIME(4)</code>, <code>TIME(5)</code>, <code>TIME(6)</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.MicroTime</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of microseconds past midnight, and does not include timezone information.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIMESTAMP(1)</code> , <code>TIMESTAMP(2)</code>, <code>TIMESTAMP(3)</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.Timestamp</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of milliseconds past epoch, and does not include timezone information.</p> </div></div></td> </tr> </tbody> </table> <div class="paragraph"> <p>When the <code>time.precision.mode</code> configuration property is set to <code>adaptive_time_microseconds</code>, then the connector will determine the literal type and semantic type for the temporal types based on the column&#8217;s data type definition so that events <em>exactly</em> represent the values in the database, except that all TIME fields will be captured as microseconds:</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 20%;"> <col style="width: 15%;"> <col style="width: 30%;"> <col style="width: 35%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">PostgreSQL Data Type</th> <th class="tableblock halign-left valign-top">Literal type (schema type)</th> <th class="tableblock halign-left valign-top">Semantic type (schema name)</th> <th class="tableblock halign-left valign-top">Notes</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIMESTAMP(4)</code> , <code>TIMESTAMP(5)</code>, <code>TIMESTAMP(6)</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.MicroTimestamp</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of milliseconds past epoch, and does not include timezone information.</p> </div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>DATE</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT32</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.Date</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of days since epoch.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIME([P])</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.MicroTime</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the time value in microseconds and does not include timezone information. PostgreSQL allows precision <code>P</code> to be in the range 0-6 to store up to microsecond precision.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIMESTAMP(1)</code> , <code>TIMESTAMP(2)</code>, <code>TIMESTAMP(3)</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.time.Timestamp</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of milliseconds past epoch, and does not include timezone information.</p> </div></div></td> </tr> </tbody> </table> <div class="paragraph"> <p>When the <code>time.precision.mode</code> configuration property is set to <code>connect</code>, then the connector will use the predefined Kafka Connect logical types. This may be useful when consumers only know about the built-in Kafka Connect logical types and are unable to handle variable-precision time values. On the other hand, since PostgreSQL supports microsecond precision, the events generated by a connector with the <code>connect</code> time precision mode will <strong>result in a loss of precision</strong> when the database column has a <em>fractional second precision</em> value greater than 3:</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 20%;"> <col style="width: 15%;"> <col style="width: 30%;"> <col style="width: 35%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">PostgreSQL Data Type</th> <th class="tableblock halign-left valign-top">Literal type (schema type)</th> <th class="tableblock halign-left valign-top">Semantic type (schema name)</th> <th class="tableblock halign-left valign-top">Notes</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIMESTAMP([P])</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>org.apache.kafka.connect.data.Timestamp</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of milliseconds since epoch, and does not include timezone information. PostgreSQL allows <code>P</code> to be in the range 0-6 to store up to microsecond precision, though this mode results in a loss of precision when <code>P</code> &gt; 3.</p> </div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>DATE</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT32</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>org.apache.kafka.connect.data.Date</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of days since epoch.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>TIME([P])</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>INT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>org.apache.kafka.connect.data.Time</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Represents the number of milliseconds since midnight, and does not include timezone information. PostgreSQL allows <code>P</code> to be in the range 0-6 to store up to microsecond precision, though this mode results in a loss of precision when <code>P</code> &gt; 3.</p> </div></div></td> </tr> </tbody> </table> </div> <div class="sect3"> <h4 id="decimal-values">Decimal values</h4> <div class="paragraph"> <p>When <code>decimal.handling.mode</code> configuration property is set to <code>precise</code>, then the connector will use the predefined Kafka Connect <code>org.apache.kafka.connect.data.Decimal</code> logical type for all <code>DECIMAL</code> and <code>NUMERIC</code> columns. This is the default mode.</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 15%;"> <col style="width: 15%;"> <col style="width: 35%;"> <col style="width: 35%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">PostgreSQL Data Type</th> <th class="tableblock halign-left valign-top">Literal type (schema type)</th> <th class="tableblock halign-left valign-top">Semantic type (schema name)</th> <th class="tableblock halign-left valign-top">Notes</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>DECIMAL[(M[,D])]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BYTES</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>org.apache.kafka.connect.data.Decimal</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The <code>scaled</code> schema parameter contains an integer representing how many digits the decimal point was shifted.</p> </div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>NUMERIC[(M[,D])]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>BYTES</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>org.apache.kafka.connect.data.Decimal</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The <code>scaled</code> schema parameter contains an integer representing how many digits the decimal point was shifted.</p> </div></div></td> </tr> </tbody> </table> <div class="paragraph"> <p>However, when <code>decimal.handling.mode</code> configuration property is set to <code>double</code>, then the connector will represent all <code>DECIMAL</code> and <code>NUMERIC</code> values as Java double values and encode them as follows:</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 15%;"> <col style="width: 15%;"> <col style="width: 35%;"> <col style="width: 35%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">PostgreSQL Data Type</th> <th class="tableblock halign-left valign-top">Literal type (schema type)</th> <th class="tableblock halign-left valign-top">Semantic type (schema name)</th> <th class="tableblock halign-left valign-top">Notes</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>DECIMAL[(M[,D])]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>FLOAT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>NUMERIC[(M[,D])]</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>FLOAT64</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> </tr> </tbody> </table> </div> <div class="sect3"> <h4 id="postgis-types">PostGIS types</h4> <div class="paragraph"> <p>The PostgreSQL connector also has limited support for some of the <a href="http://postgis.net">PostGIS data types</a></p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 20%;"> <col style="width: 15%;"> <col style="width: 30%;"> <col style="width: 35%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">PostGIS Data Type</th> <th class="tableblock halign-left valign-top">Literal type (schema type)</th> <th class="tableblock halign-left valign-top">Semantic type (schema name)</th> <th class="tableblock halign-left valign-top">Notes</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>POINT</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>STRUCT</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>io.debezium.data.geometry.Point</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Contains a structure with 2 <code>FLOAT64</code> fields - <code>(x,y)</code> - each representing the coordinates of a geometric point</p> </div></div></td> </tr> </tfoot> </table> </div> </div> <div class="sect2"> <h3 id="when-things-go-wrong">When things go wrong</h3> <div class="paragraph"> <p>Debezium is a distributed system that captures all changes in multiple upstream databases, and will never miss or lose an event. Of course, when the system is operating nominally or being administered carefully, then Debezium provides <em>exactly once</em> delivery of every change event. However, if a fault does happen then the system will still not lose any events, although while it is recovering from the fault it may repeat some change events. Thus, in these abnormal situations Debezium (like Kafka) provides <em>at least once</em> delivery of change events.</p> </div> <div class="paragraph"> <p>The rest of this section describes how Debezium handles various kinds of faults and problems.</p> </div> <div class="sect3"> <h4 id="_configuration_and_startup_errors">Configuration and startup errors</h4> <div class="paragraph"> <p>The connector will fail upon startup, report an error/exception in the log, and stop running when the connector&#8217;s configuration is invalid, when the connector cannot successfully connect to PostgreSQL using the specified connectivity parameters, or when the connector is restarting from a previously-recorded position in the PostgreSQL WAL (via the LSN value) and PostgreSQL no longer has that history available.</p> </div> <div class="paragraph"> <p>In these cases, the error will have more details about the problem and possibly a suggested work around. The connector can be restarted when the configuration has been corrected or the PostgreSQL problem has been addressed.</p> </div> </div> <div class="sect3"> <h4 id="_postgresql_becomes_unavailable">PostgreSQL becomes unavailable</h4> <div class="paragraph"> <p>Once the connector is running, if the PostgreSQL server it has been connected to becomes unavailable for any reason, the connector will fail with an error and the connector will stop. Simply restart the connector when the server is available.</p> </div> <div class="paragraph"> <p>The PostgreSQL connector stores externally the last processed offset (in the form of a PostgreSQL <code>log sequence number</code> value). Once a connector is restarted and connects to a server instance, if it has a previously stored offset it will ask the server to continue streaming from that particular offset. However, depending on the server configuration, this particular offset may or may not be available in the server&#8217;s write-ahead log segments. If it is available, then the connector will simply resume streaming changes without missing anything. If however this information is not available, the connector cannot relay back the changes that occurred while it was not online.</p> </div> </div> <div class="sect3"> <h4 id="_cluster_failures">Cluster failures</h4> <div class="paragraph"> <p>As of <code>9.6</code>, PostgreSQL allows logical replication slots <em>only on master servers</em>, which means that a PostgreSQL connector can only be pointed to the active <code>master</code> of a database cluster. If this machine goes down, only after a new <code>master</code> has been promoted (with the <a href="#output-plugin">logical decoding plugin</a> installed) can the connector be restarted and pointed to the new server.</p> </div> <div class="paragraph"> <p>One potential issue with this is that if there&#8217;s a <em>large enough delay</em> between the new server&#8217;s promotion and the installation of the plugin together with the restart of the connector, the PostgreSQL server may have removed some WAL information. If this happens, the connector will miss out on all the changes that took place <em>after the election of the new master</em> and <em>before the restart of the connector</em>.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <div class="paragraph"> <p>There are discussions in the PostgreSQL community around a feature called <code>failover slots</code> which would help mitigate this problem, but as of <code>9.6</code> they have not been implemented yet. You can find out more about this particular issue from <a href="http://blog.2ndquadrant.com/failover-slots-postgresql">this blog post</a></p> </div> </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="_kafka_connect_process_stops_gracefully">Kafka Connect process stops gracefully</h4> <div class="paragraph"> <p>If Kafka Connect is being run in distributed mode, and a Kafka Connect process is stopped gracefully, then prior to shutdown of that processes Kafka Connect will migrate all of the process' connector tasks to another Kafka Connect process in that group, and the new connector tasks will pick up exactly where the prior tasks left off. There will be a short delay in processing while the connector tasks are stopped gracefully and restarted on the new processes.</p> </div> </div> <div class="sect3"> <h4 id="_kafka_connect_process_crashes">Kafka Connect process crashes</h4> <div class="paragraph"> <p>If the Kafka Connector process stops unexpectedly, then any connector tasks it was running will obviously terminate without recording their most recently-processed offsets. When Kafka Connect is being run in distributed mode, it will restart those connector tasks on other processes. However, the PostgreSQL connectors will resume from the last offset <em>recorded</em> by the earlier processes, which means that the new replacement tasks may generate some of the same change events that were processed just prior to the crash. The number of duplicate events will depend on the offset flush period and the volume of data changes just before the crash.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <div class="paragraph"> <p>Because there is a chance that some events may be duplicated during a recovery from failure, consumers should always anticipate some events may be duplicated. Debezium change are idempotent, so a sequence of events always results in the same state.</p> </div> <div class="paragraph"> <p>Debezium also includes with each change event message the source-specific information about the origin of the event, including the PostgreSQL server&#8217;s time of the event, the id of the server transaction and the position in the write-ahead log where the transaction changes were written. Consumers can keep track of this information (especially the LSN position) to know whether they have already seen a particular event.</p> </div> </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="_kafka_becomes_unavailable">Kafka becomes unavailable</h4> <div class="paragraph"> <p>As the connector generates change events, the Kafka Connect framework records those events in Kafka using the Kafka producer API. Kafka Connect will also periodically record the latest offset that appears in those change events, at a frequency you&#8217;ve specified in the Kakfa Connect worker configuration. If the Kafka brokers become unavailable, the Kafka Connect worker process running the connectors will simply repeatedly attempt to reconnect to the Kafka brokers. In other words, the connector tasks will simply pause until a connection can be re-established, at which point the connectors will resume exactly where they left off.</p> </div> </div> <div class="sect3"> <h4 id="_connector_is_stopped_for_a_duration">Connector is stopped for a duration</h4> <div class="paragraph"> <p>If the connector is gracefully stopped, the database can continue to be used and any new changes will be recorded in the PostgreSQL WAL. When the connector is restarted, it will resume streaming changes where it last left off, recording change events for all of the changes that were made while the connector was stopped.</p> </div> <div class="paragraph"> <p>A properly configured Kafka cluster is able to <a href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines">massive throughput</a>. Kafka Connect is written with Kafka best practices, and given enough resources will also be able to handle very large numbers of database change events. Because of this, when a connector has been restarted after a while, it is very likely to catch up with the database, though how quickly will depend upon the capabilities and performance of Kafka and the volume of changes being made to the data in PostgreSQL.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <div class="paragraph"> <p>If the connector remains stopped for long enough, PostgreSQL might purge older WAL segments and the connector&#8217;s last known position may be lost. In this case, when the connector configured with <em>initial</em> snapshot mode (the default) is finally restarted, the PostgreSQL server will no longer have the starting point and the connector will perform an initial snapshot. On the other hand, if the connector&#8217;s snapshot mode is disabled, then the connector will fail with an error.</p> </div> </td> </tr> </table> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="deploying-a-connector">Deploying a connector</h2> <div class="sectionbody"> <div class="paragraph"> <p>If you&#8217;ve already installed <a href="https://zookeeper.apache.org">Zookeeper</a>, <a href="http://kafka.apache.org/">Kafka</a>, and <a href="http://kafka.apache.org/documentation.html#connect">Kafka Connect</a>, then using Debezium&#8217;s PostgreSQL connector is easy. Simply download the <a href="https://repo1.maven.org/maven2/io/debezium/debezium-connector-PostgreSQL/0.7.0/debezium-connector-PostgreSQL-0.7.0-plugin.tar.gz">connector&#8217;s plugin archive</a>, extract the JARs into your Kafka Connect environment, and add the directory with the JARs to <a href="http://docs.confluent.io/4.0.0/connect/userguide.html#installing-plugins">Kafka Connect&#8217;s classpath</a>. Restart your Kafka Connect process to pick up the new JARs.</p> </div> <div class="paragraph"> <p>If immutable containers are your thing, then check out <a href="https://hub.docker.com/r/debezium/">Debezium&#8217;s Docker images</a> for Zookeeper, Kafka, PostgreSQL and Kafka Connect with the PostgreSQL connector already pre-installed and ready to go. You can even <a href="/blog/2016/05/31/Debezium-on-Kubernetes">run Debezium on Kubernetes and OpenShift</a>.</p> </div> <div class="paragraph"> <p>To use the connector to produce change events for a particular PostgreSQL server or cluster:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>install the <a href="#output-plugin">logical decoding plugin</a></p> </li> <li> <p>configure the <a href="#server-configuration">PostgreSQL server</a> to support logical replication</p> </li> <li> <p>create a <a href="#example-configuration">configuration file for the PostgreSQL Connector</a> and use the <a href="http://docs.confluent.io/4.0.0/connect/userguide.html#rest-interface">Kafka Connect REST API</a> to add that connector to your Kafka Connect cluster.</p> </li> </ol> </div> <div class="paragraph"> <p>When the connector starts, it will grab a consistent snapshot of the databases in your PostgreSQL server and start streaming changes, producing events for every inserted, updated, and deleted row. You can also choose to produce events for a subset of the schemas and tables. Optionally ignore, mask, or truncate columns that are sensitive, too large, or not needed.</p> </div> <div class="sect2"> <h3 id="example-configuration">Example configuration</h3> <div class="paragraph"> <p>Using the PostgreSQL connector is straightforward. Here is an example of the configuration for a PostgreSQL connector that monitors a PostgreSQL server at port 5432 on 192.168.99.100, which we logically name <code>fullfillment</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-json" data-lang="json">{&#x000A;  "name": "inventory-connector",  <i class="conum" data-value="1"></i><b>(1)</b>&#x000A;  "config": {&#x000A;    "connector.class": "io.debezium.connector.postgresql.PostgresConnector", <i class="conum" data-value="2"></i><b>(2)</b>&#x000A;    "database.hostname": "192.168.99.100", <i class="conum" data-value="3"></i><b>(3)</b>&#x000A;    "database.port": "5432", <i class="conum" data-value="4"></i><b>(4)</b>&#x000A;    "database.user": "postgres", <i class="conum" data-value="5"></i><b>(5)</b>&#x000A;    "database.password": "postgres", <i class="conum" data-value="6"></i><b>(6)</b>&#x000A;    "database.dbname" : "postgres", <i class="conum" data-value="7"></i><b>(7)</b>&#x000A;    "database.server.name": "fullfillment", <i class="conum" data-value="8"></i><b>(8)</b>&#x000A;    "table.whitelist": "public.inventory" <i class="conum" data-value="9"></i><b>(9)</b>&#x000A;&#x000A;  }&#x000A;}</code></pre> </div> </div> <div class="colist arabic"> <table> <tr> <td><i class="conum" data-value="1"></i><b>1</b></td> <td>The name of our connector when we register it with a Kafka Connect service.</td> </tr> <tr> <td><i class="conum" data-value="2"></i><b>2</b></td> <td>The name of this PostgreSQL connector class.</td> </tr> <tr> <td><i class="conum" data-value="3"></i><b>3</b></td> <td>The address of the PostgreSQL server.</td> </tr> <tr> <td><i class="conum" data-value="4"></i><b>4</b></td> <td>The port number of the PostgreSQL server.</td> </tr> <tr> <td><i class="conum" data-value="5"></i><b>5</b></td> <td>The name of the PostgreSQL user that has the <a href="#PostgreSQL-permissions">required privileges</a>.</td> </tr> <tr> <td><i class="conum" data-value="6"></i><b>6</b></td> <td>The password for the PostgreSQL user that has the <a href="#PostgreSQL-permissions">required privileges</a>.</td> </tr> <tr> <td><i class="conum" data-value="7"></i><b>7</b></td> <td>The name of the PostgreSQL database to connect to</td> </tr> <tr> <td><i class="conum" data-value="8"></i><b>8</b></td> <td>The logical name of the PostgreSQL server/cluster, which forms a namespace and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the <a href="#avro-converter">Avro Connector</a> is used.</td> </tr> <tr> <td><i class="conum" data-value="9"></i><b>9</b></td> <td>A list of all tables hosted by this server that this connector will monitor. This is optional, and there are other properties for listing the schemas and tables to include or exclude from monitoring.</td> </tr> </table> </div> <div class="paragraph"> <p>See the <a href="#connector-properties">complete list of connector properties</a> that can be specified in these configurations.</p> </div> <div class="paragraph"> <p>This configuration can be sent via POST to a running Kafka Connect service, which will then record the configuration and start up the one connector task that will connect to the PostgreSQL database and record events to Kafka topics.</p> </div> </div> <div class="sect2"> <h3 id="connector-properties">Connector properties</h3> <div class="paragraph"> <p>The following configuration properties are <em>required</em> unless a default value is available.</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 35%;"> <col style="width: 10%;"> <col style="width: 55%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Property</th> <th class="tableblock halign-left valign-top">Default</th> <th class="tableblock halign-left valign-top">Description</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.tcpKeepAlive</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Enable TCP keep-alive probe to verify that database connection is still alive. (disabled by default). See <a href="https://www.postgresql.org/docs/9.6/static/libpq-connect.html">the PostgreSQL documentation</a> for more information.</p> </div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>name</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>connector.class</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The name of the Java class for the connector. Always use a value of <code>io.debezium.connector.postgresql.PostgresConnector</code> for the PostgreSQL connector.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>tasks.max</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>1</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The maximum number of tasks that should be created for this connector. The PostgreSQL connector always uses a single task and therefore does not use this value, so the default is always acceptable.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>plugin.name</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>decoderbufs</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The name of the Postgres <a href="#output-plugin">logical decoding plugin</a> installed on the server. Supported values are either <code>decoderbufs</code> or <code>wal2json</code>.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>slot.name</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>debezium</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The name of the Postgres logical decoding slot created for streaming changes from a plugin and database instance.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>slot.drop_on_stop</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>false</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Whether or not to drop the logical replication slot when the connector finishes orderly.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.hostname</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>IP address or hostname of the PostgreSQL database server.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.port</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>5432</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Integer port number of the PostgreSQL database server.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.user</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Name of the PostgreSQL database to use when when connecting to the PostgreSQL database server.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.password</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Password to use when when connecting to the PostgreSQL database server.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.dbname</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The name of the PostgreSQL database from which to stream the changes</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.server.name</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><em>host:port</em>/<em>dbname</em></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Logical name that identifies and provides a namespace for the particular PostgreSQL database server/cluster being monitored. The logical name should be unique across all other connectors, since it is used as a prefix for all Kafka topic names coming from this connector. Defaults to '<em>host</em>:_port_/<em>dbname</em>', where <em>host</em> is the value of the <code>database.hostname</code> property and <em>port</em> is the value of the <code>database.port</code> property and <em>dbname</em> is the value of the <code>database.dbname</code> property, though we recommend using an explicit and meaningful logical name.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>schema.whitelist</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>An optional comma-separated list of regular expressions that match schema names to be monitored; any schema name not included in the whitelist will be excluded from monitoring. By default all non-system schemas will be monitored. May not be used with <code>database.blacklist</code>.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>schema.blacklist</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>An optional comma-separated list of regular expressions that match schema names to be excluded from monitoring; any schema name not included in the blacklist will be monitored, with the exception of system schemas. May not be used with <code>schema.whitelist</code>.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>table.whitelist</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be monitored; any table not included in the whitelist will be excluded from monitoring. Each identifier is of the form <em>schemaName</em>.<em>tableName</em>. By default the connector will monitor every non-system table in each monitored schema. May not be used with <code>table.blacklist</code>.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>table.blacklist</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be excluded from monitoring; any table not included in the blacklist will be monitored. Each identifier is of the form <em>schemaName</em>.<em>tableName</em>. May not be used with <code>table.whitelist</code>.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>column.blacklist</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>An optional comma-separated list of regular expressions that match the fully-qualified names of columns that should be excluded from change event message values. Fully-qualified names for columns are of the form <em>schemaName</em>.<em>tableName</em>.<em>columnName</em></p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>time.precision.mode</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>adaptive</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Time, date, and timestamps can be represented with different kinds of precisions, including: <code>adaptive</code> (the default) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column&#8217;s type; <code>adaptive_time_microseconds</code> captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column&#8217;s type, with the exception of TIME type fields, which are always captured as microseconds; or <code>connect</code> always represents time and timestamp values using Kafka Connect&#8217;s built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision. See <a href="#temporal-values">temporal values</a>.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.sslmode</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>disabled</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Whether to use an encrypted connection to the PostgreSQL server. Options include: <strong>disabled</strong> (the default) to use an unencrypted connection ; <strong>required</strong> to use a secure (encrypted) connection, and fail if one cannot be established; <strong>verify_ca</strong> like <code>required</code> but additionally verify the server TLS certificate against the configured Certificate Authority (CA) certificates, or fail if no valid matching CA certificates are found; <strong>verify_full</strong> like <code>verify_ca</code> but additionally verify that the server certificate matches the host to which the connection is attempted. See <a href="https://www.postgresql.org/docs/9.6/static/libpq-connect.html">the PostgreSQL documentation</a> for more information.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.sslcert</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The path to the file containing the SSL Certificate for the client. See <a href="https://www.postgresql.org/docs/9.6/static/libpq-connect.html">the PostgreSQL documentation</a> for more information.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.sslkey</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The path to the file containing the SSL private key of the client. See <a href="https://www.postgresql.org/docs/9.6/static/libpq-connect.html">the PostgreSQL documentation</a> for more information.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.sslpassword</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The password to access the client private key from the file specified by <code>database.sslkey</code>. See <a href="https://www.postgresql.org/docs/9.6/static/libpq-connect.html">the PostgreSQL documentation</a> for more information.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>database.sslrootcert</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>The path to the file containing the root certificate(s) against which the server is validated. See <a href="https://www.postgresql.org/docs/9.6/static/libpq-connect.html">the PostgreSQL documentation</a> for more information.</p> </div></div></td> </tr> </tbody> </table> <div class="paragraph"> <p>The following <em>advanced</em> configuration properties have good defaults that will work in most situations and therefore rarely need to be specified in the connector&#8217;s configuration.</p> </div> <table class="tableblock frame-all grid-all spread table table-bordered table-striped"> <colgroup> <col style="width: 35%;"> <col style="width: 10%;"> <col style="width: 55%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Property</th> <th class="tableblock halign-left valign-top">Default</th> <th class="tableblock halign-left valign-top">Description</th> </tr> </thead> <tfoot> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>include.unknown.datatypes</code><br> 0.7.0 and later</p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>false</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>When Debezium meets a field whose data type is unknown, then by default the field is omitted from the change event and a warning is logged. In some cases it may be preferable though to include the field and send it downstream to clients in the opaque binary representation so the clients will decode it themselves. Set to <code>false</code> to filter unknown data out of events and <code>true</code> to keep them in binary format.</p> </div> <div class="paragraph"> <p><em>Note: The clients risk backward compatibility issues. Not only may the database specific binary representation change between releases, but also when the datatype is supported by Debezium eventually, it will be sent downstream in a logical type, requiring adjustments by consumers. In general, when encountering unsupported data types, please file a feature request so that support can be added.</em></p> </div></div></td> </tr> </tfoot> <tbody> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>snapshot.mode</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>initial</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Specifies the criteria for running a snapshot upon startup of the connector. The default is <strong>initial</strong>, and specifies the connector can run a snapshot only when no offsets have been recorded for the logical server name. The <strong>always</strong> option specifies that the connector run a snapshot each time on startup. The <strong>never</strong> option specifies that the connect should never use snapshots and that upon first startup with a logical server name the connector should read from either from where it last left off (last LSN position) or start from the beginning from the point of the view of the logical replication slot. Finally, the <strong>initial_only</strong> option specifies that the connector should only take an initial snapshot and then stop, without processing any subsequent changes. See <a href="#snapshots">snapshosts</a></p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>snapshot.lock.timeout.ms</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>10000</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Positive integer value that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If table locks cannot be aquired in this time interval, the snapshot will fail See <a href="#snapshots">snapshosts</a></p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>rows.fetch.size</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>10240</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Positive integer value that specifies the maximum number of rows that should be read from each table while taking a snapshot</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>max.queue.size</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>20240</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Positive integer value that specifies the maximum size of the blocking queue into which change events received via streaming replication are placed before they are written to Kafka. This queue can provide backpressure when, for example, writes to Kafka are slower or if Kafka is not available.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>max.batch.size</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>10240</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector.</p> </div></div></td> </tr> <tr> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>poll.interval.ms</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p><code>1000</code></p> </div></div></td> <td class="tableblock halign-left valign-top"><div><div class="paragraph"> <p>Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear. Defaults to 1000 milliseconds, or 1 second.</p> </div></div></td> </tr> </tbody> </table> <div class="paragraph"> <p>The connector also supports <em>pass-through</em> configuration properties that are used when creating the Kafka producer and consumer.</p> </div> <div class="paragraph"> <p>Be sure to consult the <a href="http://kafka.apache.org/documentation.html">Kafka documentation</a> for all of the configuration properties for Kafka producers and consumers. (The PostgreSQL connector does use the <a href="http://kafka.apache.org/documentation.html#newconsumerconfigs">new consumer</a>.)</p> </div> </div> </div> </div> </div> </div> </div> <footer class="container"> <div class="row"> <div class="col-md-5 col-md-offset-1"> <h4>Debezium</h4> <p> &#169; 2017 Debezium Community <br> <br> <i class="icon-fire"></i> Mixed with <a href="http://twitter.github.com/bootstrap">Bootstrap</a>, baked by <a href="http://awestruct.org">Awestruct</a>. <br> <i class="icon-flag"></i> Website and docs licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>. <br> <i class="icon-flag-alt"></i> Code released under <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License, v2.0</a>. <br> <i class="icon-file-alt"></i> <a href="http://www.redhat.com/legal/legal_statement.html" title="Terms">Terms</a> | <a href="http://www.redhat.com/legal/privacy_statement.html" title="Privacy Policy">Privacy</a> </p> </div> <div class="col-md-3"> <h4>Documentation</h4> <ul class="list-unstyled"> <li> <a href="/docs/features" title="Features">Features</a> </li> <li> <a href="/docs/install" title="Install">Install</a> </li> <li> <a href="/docs/manage" title="Manage">Manage</a> </li> <li> <a href="/docs/architecture" title="Architecture">Architecture</a> </li> <li> <a href="/docs/faq" title="FAQ">FAQ</a> </li> <li> <a href="/docs/contribute" title="Contribute">Contribute</a> </li> </ul> </div> <div class="col-md-3"> <h4>Connect</h4> <ul class="list-unstyled"> <li> <a href="/blog" title="Blog">Blog</a> </li> <li> <a href="http://twitter.com/debezium" title="Twitter">Twitter</a> </li> <li> <a href="http://github.com/debezium" title="GitHub">GitHub</a> </li> <li> <a href="https://gitter.im/debezium/dev" title="Chat">Chat</a> </li> <li> <a href="https://groups.google.com/forum/#!forum/debezium" title="Google Groups">Google Groups</a> </li> <li> <a href="http://stackoverflow.com/questions/tagged/debezium" title="StackOverflow">StackOverflow</a> </li> </ul> </div> </div> </footer> <div class="container" id="companyfooter"> <div class="redhatlogo"> <div id="logospacer"></div> <a href="http://www.redhat.com/"><img src="http://static.jboss.org/theme/images/common/redhat_logo.png"></a> </div> </div> <span class="backToTop"> <a href="#top">back to top</a> </span> <script src="http://static.jboss.org/theme/js/libs/bootstrap-community/3.2.0.1/bootstrap-community.min.js"></script> <script type='text/javascript' language='JavaScript' src='http://www.redhat.com/j/elqNow/elqCfg.js'></script> <script type='text/javascript' language='JavaScript' src='http://www.redhat.com/j/elqNow/elqImg.js'></script> <div id="oTags"> <script type="text/javascript" src="//www.redhat.com/j/s_code.js"></script> <script type="text/javascript"><!--
        var coreUrl = encodeURI(document.URL.split("?")[0]).replace(/-/g," ");
        var urlSplit = coreUrl.toLowerCase().split(/\//);
        var urlLast = urlSplit[urlSplit.length-1];
        var pageNameString = "";
        var siteName = "";
        var minorSectionIndex = 3
        if (urlLast == "") {
            urlSplit.splice(-1,1);
        }
        if (urlLast.search(/\./) >= 0) {
            if (urlLast == "index.html") {
                urlSplit.splice(-1,1);
            }
            else {
                urlSplit[urlSplit.length-1] = urlLast.split(".").splice(0,1);
            }
        }
        siteName = urlSplit[2].split(".")[1];
        s.prop14 = s.eVar27 = siteName || "";
        s.prop15 = s.eVar28 = urlSplit[minorSectionIndex] || "";
        s.prop16 = s.eVar29 = urlSplit[minorSectionIndex+1] || "";
        pageNameString = urlSplit.splice(3).join(" | ");
        s.pageName = "jboss | community | " + siteName + " | " + pageNameString;
        s.server = "jboss";
        s.channel = "jboss | community";
        s.prop4 = s.eVar23 = encodeURI(document.URL);
        s.prop21 = s.eVar18 = coreUrl;
        s.prop2 = s.eVar22 = "en";
        s.prop3 = s.eVar19 = "us";
        //--></script> <script type="text/javascript" src="//www.redhat.com/j/rh_omni_footer.js"></script> <script language="JavaScript" type="text/javascript"><!--
        if(navigator.appVersion.indexOf('MSIE')>=0)document.write(unescape('%3C')+'\!-'+'-')
        //--></script> <noscript><a href="http://www.omniture.com" title="Web Analytics"><img src="https://smtrcs.redhat.com/b/ss/redhatcom,redhatglobal/1/H.25.4--NS/0?[AQB]&cdp=3&[AQE]" height="1" width="1" border="0" alt=""/></a></noscript> </div> <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
      </script> <script type="text/javascript">
      try {
      var pageTracker = _gat._getTracker("UA-10656779-1");
      pageTracker._trackPageview();
      } catch(err) {}</script> <script>
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      
                          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      
                          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      
                          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
       
      ga('create', 'UA-76464546-1', 'auto');
      ga('send', 'pageview');
      ga('set', 'anonymizeIp', true);
      ga('require', 'linkid', 'linkid.js');
      
      </script> </div> </body> </html>